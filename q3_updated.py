# -*- coding: utf-8 -*-
"""Q3_updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dN1HXVCFKpSeVL3LF-etfmf2kmvM0-X2

**Finding Best possible warehouse locations based on store locations**
"""

!apt install proj-bin libproj-dev libgeos-dev
#!apt install proj-bin libproj-dev reverse_geocoder
#!apt install proj-bin libproj-dev pprint

!pip install https://github.com/matplotlib/basemap/archive/v1.1.0.tar.gz

!pip install -U git+https://github.com/matplotlib/basemap.git
#import reverse_geocoder as rg 
#import pprint

# Commented out IPython magic to ensure Python compatibility.
from mpl_toolkits.basemap import Basemap  # Referenced from "https://rabernat.github.io/research_computing/intro-to-basemap.html"
import matplotlib
from PIL import Image
import matplotlib.pyplot as plt
from pylab import rcParams
# %matplotlib inline
rcParams['figure.figsize'] = (14,10)

from sklearn.cluster import DBSCAN  # Referenced from "https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html"
import sklearn.utils
from sklearn.preprocessing import StandardScaler

import pandas as pd 
from google.colab import files
uploaded = files.upload()

import io
import numpy as np
df= pd.read_csv(io.BytesIO(uploaded['q3dbscan.csv']))
print(df.shape)

df.dropna(subset=['Lat','Long'],inplace=True)

df

print("Lat max",df['Lat'].max())
print("Lat min",df['Lat'].min())
print("Long max",df['Long'].max())
print("Long min",df['Long'].min())

my_map = Basemap(projection='merc',resolution='l',area_thresh=1000,llcrnrlat=25.753,llcrnrlon=-152,urcrnrlat=57.79,urcrnrlon=-7.539)
my_map.drawstates()
my_map.drawlsmask(land_color='orange',ocean_color='skyblue')
my_map.bluemarble()
my_map.etopo()

my_map.drawstates()
my_map.drawlsmask(land_color='orange',ocean_color='skyblue')
my_map.bluemarble()
my_map.etopo()

xs,ys=my_map(np.asarray(df.Long),np.asarray(df.Lat))
df['xm']= xs.tolist()
df['ym'] =ys.tolist()

df_cluster=df[["Long","Lat"]]
df_cluster=StandardScaler().fit_transform(df_cluster)
x = np.array(df_cluster)
cls=DBSCAN(eps=0.7,min_samples=30).fit(x)
labels=cls.labels_
df["Clus_Db"]=labels

#realClusterNum=len(set(labels)) - (1 if -1 in labels else 0)
clusterNum = len(set(labels))
print(labels)
for index,row in df.iterrows():
   x,y = my_map(row.Long, row.Lat)
   my_map.plot(x, y,markerfacecolor ='red',markeredgecolor='black', marker='s', markersize= 0.01, alpha = 0.4)

labels # labels for each of the clusters

import numpy

numpy.unique(labels) # unique labels for the clusters

def dist(a, b, ax=1):
    return np.linalg.norm(a - b, axis=ax)

k = 4
x_vals = np.random.randint(0, np.max(df['xm'])-10, size=k)
y_vals = np.random.randint(0, np.max(df['ym'])-10, size=k)
cities = np.array(list(zip(x_vals, y_vals)), dtype=np.float32)
print(cities)
values = []
x = np.asarray(df.Long)
y = np.asarray(df.Lat)
labels_array = np.asarray(labels)
x1 = []
x2 = []

y1 = []
y2 = []
for i in range(0,len(x)):
  if labels_array[i] == 1:
    x1.append(x[i])
    y1.append(y[i])
  elif labels_array[i] == 0:
    x2.append(x[i])
    y2.append(y[i])
     
print(x1)     
print(y1)
print(y2)
print(x2)

def convert_to_cartisan(cities):

    for coordinates in cities:
        latitude = float(coordinates[1])
        longitude = float(coordinates[2])
        radius_earth = 6731

        flat = radius_earth * math.cos(latitude) * math.cos(longitude) , radius_earth * math.cos(latitude) * math.sin(longitude) , radius_earth * math.sin(latitude)
    return flat

#print (convert_to_cartisan(cities))

def combine(x, y): 
      
    combined = [(x[i], y[i]) for i in range(0, len(x))] 
    return combined 
list1 = combine(x1,y1)
list2 = combine(x2,y2)

def centroid(lst):
   lat_coords = []
   long_coords = []
   for l in lst :
      lat_coords.append(l[0])
      long_coords.append(l[1])
      cent_x = sum(lat_coords)/len(lat_coords)
      cent_y = sum(long_coords)/len(long_coords)
   return (cent_x,cent_y)

print(centroid(list1))
print(centroid(list2))